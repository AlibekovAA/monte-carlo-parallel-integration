Scheme MonteCarlo
{
    N = [1];
    P = [2];
    @ = ((N * P).GenerateArrays.CountPoints * N).CalcResult.("Integral value: ".print).print;

    Fun GenerateArrays
    {
        Count = [1];
        Threads = [2];

        ArrayX = (Count * 0.0).arrayCreate;
        ArrayY = (Count * 0.0).arrayCreate;

        @ = (ArrayX * ArrayY * 0).Recurse;
    }

    Fun Recurse
    {
        ArrayX = [1];
        ArrayY = [2];
        CurI = [3];
        Len = ArrayX.arrayLen;

        @ = (CurI * Len).less ->
            ((ArrayX * CurI * (rand * 5.0).mul).arraySet * (ArrayY * CurI * (rand * 5.0).mul).arraySet * (CurI * 1).add).Recurse,
            (ArrayX * ArrayY);
    }

    Fun CountPoints
    {
        ArrayX = [1];
        ArrayY = [2];

        @ = (ArrayX * ArrayY * 0 * 0).RecurseCount;
    }

    Fun RecurseCount
    {
        ArrayX = [1];
        ArrayY = [2];
        CurI = [3];
        Count = [4];
        Len = ArrayX.arrayLen;

        @ = (CurI * Len).less ->
            (ArrayX * ArrayY * (CurI * 1).add *
                ((((ArrayX * CurI).arrayGet * (ArrayY * CurI).arrayGet).CheckPoint -> 1, 0) * Count).add
            ).RecurseCount,
            Count;
    }

    Fun CheckPoint
    {
        X = [1];
        Y = [2];

        @ = (Y * ((X.sin * (X.cos * 2.0).mul).add)).less;
    }

    Fun CalcResult
    {
        Points = [1];
        Total = [2];

        @ = (Points.toReal * 25.0 * Total.toReal).div;
    }
}

Application
N = 10000;
P = 4;
% MonteCarlo(N, P)
